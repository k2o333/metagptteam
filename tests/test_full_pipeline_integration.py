
import pytest
from unittest.mock import patch
from metagpt.team import Team
import sys
import os
sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))
from run import main

@pytest.mark.asyncio
async def test_full_pipeline_integration(tmp_path):
    # Mock the OUTPUT_PATH in run.py to use a temporary directory
    with patch("run.OUTPUT_PATH", tmp_path):
        with patch('metagpt.team.Team.run') as mock_team_run:
            mock_team_run.side_effect = lambda *args, **kwargs: None # Mock team.run to do nothing
            await main("Write a simple tutorial about pytest.")

            # Manually simulate the DocAssembler receiving a FullDraft message
            from metagpt_doc_writer.schemas.doc_structures import FullDraft
            from metagpt.schema import Message
            dummy_full_draft = FullDraft(content="# Test Document

This is a test document generated by the integration test.")
            dummy_message = Message(content="Finalize document", instruct_content=dummy_full_draft)

            from metagpt_doc_writer.roles.doc_assembler import DocAssembler
            doc_assembler_instance = DocAssembler(output_path=tmp_path) # Create a new instance for testing
            
            # Add the message to the role's message queue and then call _act
            doc_assembler_instance.rc.news.append(dummy_message)
            await doc_assembler_instance._act()

        # Verify actual file output
        output_files = list(tmp_path.glob("*.md"))
        assert len(output_files) > 0, "No markdown file was created."
        
        # Check that the content of the created file is correct
        file_content = output_files[0].read_text()
        assert "# Test Document" in file_content
        assert "This is a test document" in file_content
