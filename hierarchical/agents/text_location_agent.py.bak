#!/usr/bin/env python3
"""
Text Location Agent based on RoleZero
ä¸“é—¨ç”¨äºç²¾ç¡®ç¡®è®¤æ–‡æ¡£ä¸­éœ€è¦ä¿®æ”¹çš„ä½ç½®
"""

import sys
import json
import re
from pathlib import Path
from typing import Dict, List, Optional, Tuple

# Add project root to path
PROJECT_ROOT = Path(__file__).resolve().parent.parent.parent
sys.path.insert(0, str(PROJECT_ROOT))

from metagpt.roles.di.role_zero import RoleZero
from metagpt.tools.libs.editor import Editor
from metagpt.logs import logger
from metagpt.actions import Action
from metagpt.schema import Message


class ConfirmTextLocation(Action):
    """ç¡®è®¤æ–‡æœ¬ä½ç½®çš„Action"""
    
    def __init__(self, name: str = "Confirm Text Location", **kwargs):
        super().__init__(name=name, **kwargs)
        self.editor = Editor()
    
    def run(self, document_path: str, search_text: str, 
                  approximate_line: int = None, approximate_char: int = None,
                  context_chars: int = 100) -> Dict:
        """
        ç²¾ç¡®ç¡®è®¤æ–‡æœ¬ä½ç½®
        
        Args:
            document_path: æ–‡æ¡£è·¯å¾„
            search_text: è¦æŸ¥æ‰¾çš„æ–‡æœ¬
            approximate_line: LLMæä¾›çš„è¿‘ä¼¼è¡Œå·
            approximate_char: LLMæä¾›çš„è¿‘ä¼¼å­—ç¬¦ä½ç½®
            context_chars: ä¸Šä¸‹æ–‡å­—ç¬¦æ•°
            
        Returns:
            Dict with precise location and context info
        """
        logger.info(f"ğŸ” ç²¾ç¡®å®šä½æ–‡æœ¬: '{search_text[:50]}...'")
        
        try:
            # è¯»å–æ–‡æ¡£å†…å®¹
            import asyncio
            file_content = asyncio.run(self.editor.read(document_path))
            content = file_content.block_content
            
            # æ–¹æ³•1: ç›´æ¥ç²¾ç¡®æœç´¢
            direct_result = self._direct_search(content, search_text)
            if direct_result:
                logger.info("âœ… ç›´æ¥æœç´¢æˆåŠŸæ‰¾åˆ°æ–‡æœ¬")
                return self._add_context_info(content, direct_result, context_chars)
            
            # æ–¹æ³•2: åœ¨è¿‘ä¼¼ä½ç½®é™„è¿‘æœç´¢
            if approximate_line is not None:
                nearby_result = self._search_near_approximate_position(
                    content, search_text, approximate_line)
                if nearby_result:
                    logger.info("âœ… åœ¨è¿‘ä¼¼ä½ç½®é™„è¿‘æ‰¾åˆ°æ–‡æœ¬")
                    return self._add_context_info(content, nearby_result, context_chars)
            
            # æ–¹æ³•3: æ¨¡ç³Šæœç´¢
            fuzzy_result = self._fuzzy_search(content, search_text)
            if fuzzy_result:
                logger.info("âœ… æ¨¡ç³Šæœç´¢æ‰¾åˆ°æ–‡æœ¬")
                return self._add_context_info(content, fuzzy_result, context_chars)
                
            # æœªæ‰¾åˆ°
            logger.error(f"âŒ æœªæ‰¾åˆ°æ–‡æœ¬: '{search_text}'")
            return {
                "found": False,
                "error": f"æœªæ‰¾åˆ°æ–‡æœ¬: '{search_text}'",
                "search_text": search_text
            }
            
        except Exception as e:
            logger.error(f"ç²¾ç¡®å®šä½æ—¶å‡ºé”™: {e}")
            return {
                "found": False,
                "error": f"å®šä½é”™è¯¯: {str(e)}",
                "search_text": search_text
            }
    
    def _direct_search(self, content: str, search_text: str) -> Optional[Dict]:
        """ç›´æ¥ç²¾ç¡®æœç´¢"""
        pos = content.find(search_text)
        if pos != -1:
            return self._calculate_location(content, pos, len(search_text))
        return None
    
    def _search_near_approximate_position(self, content: str, search_text: str, 
                                        approx_line: int) -> Optional[Dict]:
        """åœ¨è¿‘ä¼¼ä½ç½®é™„è¿‘æœç´¢"""
        lines = content.splitlines()
        if approx_line < 0 or approx_line >= len(lines):
            return None
            
        # æœç´¢èŒƒå›´ï¼šå‰å5è¡Œ
        start_line = max(0, approx_line - 5)
        end_line = min(len(lines) - 1, approx_line + 5)
        
        # æ„é€ æœç´¢èŒƒå›´çš„å†…å®¹
        search_range_content = "\n".join(lines[start_line:end_line + 1])
        pos_in_range = search_range_content.find(search_text)
        
        if pos_in_range != -1:
            # è®¡ç®—åœ¨æ•´ä¸ªæ–‡æ¡£ä¸­çš„ä½ç½®
            lines_before = "\n".join(lines[:start_line])
            if lines_before:
                full_pos = len(lines_before) + 1 + pos_in_range  # +1 for newline
            else:
                full_pos = pos_in_range
            return self._calculate_location(content, full_pos, len(search_text))
            
        return None
    
    def _fuzzy_search(self, content: str, search_text: str) -> Optional[Dict]:
        """æ¨¡ç³Šæœç´¢"""
        # ä½¿ç”¨æ­£åˆ™è¡¨è¾¾å¼ï¼Œå…è®¸ç©ºç™½å­—ç¬¦å˜åŒ–
        escaped_text = re.escape(search_text)
        # å…è®¸ä¸€äº›ç©ºç™½å­—ç¬¦å˜åŒ–
        pattern = escaped_text.replace(r'\ ', r'\s*')
        
        match = re.search(pattern, content)
        if match:
            return self._calculate_location(content, match.start(), match.end() - match.start())
        return None
    
    def _calculate_location(self, content: str, start_pos: int, length: int) -> Dict:
        """è®¡ç®—ä½ç½®ä¿¡æ¯"""
        text_before_start = content[:start_pos]
        start_line = text_before_start.count('\n')
        
        last_newline_start = text_before_start.rfind('\n')
        if last_newline_start == -1:
            start_char = start_pos
        else:
            start_char = start_pos - last_newline_start - 1
            
        end_pos = start_pos + length
        text_before_end = content[:end_pos]
        end_line = text_before_end.count('\n')
        
        last_newline_end = text_before_end.rfind('\n')
        if last_newline_end == -1:
            end_char = end_pos
        else:
            end_char = end_pos - last_newline_end - 1
            
        return {
            "found": True,
            "start_line": start_line,
            "start_char": start_char,
            "end_line": end_line,
            "end_char": end_char,
            "start_pos": start_pos,
            "end_pos": end_pos,
            "length": length
        }
    
    def _add_context_info(self, content: str, location: Dict, context_chars: int) -> Dict:
        """æ·»åŠ ä¸Šä¸‹æ–‡ä¿¡æ¯"""
        if not location.get("found"):
            return location
            
        start_pos = location["start_pos"]
        # æå–å‰åä¸Šä¸‹æ–‡
        context_start = max(0, start_pos - context_chars)
        context_end = min(len(content), start_pos + location["length"] + context_chars)
        
        context = content[context_start:context_end]
        
        location["context"] = context
        location["context_start_pos"] = context_start
        location["context_end_pos"] = context_end
        
        return location


class TextLocationAgent(RoleZero):
    """ç²¾ç¡®å®šä½æ–‡æœ¬çš„Agent"""
    
    name: str = "TextLocationAgent"
    profile: str = "Precise Text Location Agent"
    goal: str = "Accurately locate text positions in documents for precise replacement"
    
    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        # æ·»åŠ ç¡®è®¤æ–‡æœ¬ä½ç½®çš„Action
        self.set_actions([ConfirmTextLocation()])
        self._watch(["TextLocationRequest", "UserRequirement"])
        
    async def _think(self) -> bool:
        """æ€è€ƒè¦æ‰§è¡Œçš„ä»»åŠ¡"""
        if not self.rc.news:
            return False
            
        latest_msg = self.rc.news[-1]
        
        if latest_msg.cause_by in ["TextLocationRequest", "UserRequirement"]:
            self.rc.todo = "CONFIRM_TEXT_LOCATION"
            return True
            
        return False
    
    async def _act(self) -> Message:
        """æ‰§è¡Œç²¾ç¡®å®šä½ä»»åŠ¡"""
        logger.info(f"--- {self.name} æ­£åœ¨æ‰§è¡Œç²¾ç¡®å®šä½ ---")
        
        await self._think()
        
        if self.rc.todo != "CONFIRM_TEXT_LOCATION":
            return None
            
        latest_msg = self.rc.news[-1]
        
        try:
            # è§£æè¯·æ±‚æ•°æ®
            request_data = json.loads(latest_msg.content)
            document_path = request_data.get("document_path")
            search_text = request_data.get("search_text")
            approx_line = request_data.get("approximate_line")
            approx_char = request_data.get("approximate_char")
            
            if not document_path or not search_text:
                return Message(
                    content="é”™è¯¯: ç¼ºå°‘æ–‡æ¡£è·¯å¾„æˆ–æœç´¢æ–‡æœ¬",
                    role=self.profile,
                    send_to="ChangeCoordinator"
                )
            
            # æ‰§è¡Œç²¾ç¡®å®šä½
            confirm_action = self.actions[0]  # ConfirmTextLocation
            result = await confirm_action.run(
                document_path=document_path,
                search_text=search_text,
                approximate_line=approx_line,
                approximate_char=approx_char
            )
            
            # è¿”å›ç»“æœ
            return Message(
                content=json.dumps(result, ensure_ascii=False),
                role=self.profile,
                send_to="ChangeCoordinator",
                cause_by="TextLocationConfirmed"
            )
            
        except json.JSONDecodeError as e:
            logger.error(f"è§£æè¯·æ±‚æ•°æ®å¤±è´¥: {e}")
            return Message(
                content=f"é”™è¯¯: è§£æè¯·æ±‚æ•°æ®å¤±è´¥: {e}",
                role=self.profile,
                send_to="ChangeCoordinator"
            )
        except Exception as e:
            logger.error(f"æ‰§è¡Œç²¾ç¡®å®šä½æ—¶å‡ºé”™: {e}")
            return Message(
                content=f"é”™è¯¯: æ‰§è¡Œç²¾ç¡®å®šä½æ—¶å‡ºé”™: {e}",
                role=self.profile,
                send_to="ChangeCoordinator"
            )


def main():
    """æµ‹è¯•ç²¾ç¡®å®šä½Agent"""
    print("Text Location Agent æµ‹è¯•")
    
    # è¿™é‡Œå¯ä»¥æ·»åŠ æµ‹è¯•ä»£ç 
    agent = TextLocationAgent()
    print(f"Agentåˆ›å»ºæˆåŠŸ: {agent.name}")


if __name__ == "__main__":
    main()