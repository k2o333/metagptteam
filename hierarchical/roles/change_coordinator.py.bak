import sys
import json
from pathlib import Path
from typing import Any, Dict

# --- Path Setup ---
PROJECT_ROOT = Path(__file__).resolve().parent.parent.parent
METAGPT_ROOT = PROJECT_ROOT.parent / "metagpt"
sys.path.insert(0, str(PROJECT_ROOT))
sys.path.insert(0, str(METAGPT_ROOT))
# ------------------

from metagpt.actions import Action
from metagpt.logs import logger
from metagpt.schema import Message
from hierarchical.roles.base_role import HierarchicalBaseRole
from hierarchical.actions.analyze_changes import AnalyzeChanges

class ChangeCoordinator(HierarchicalBaseRole):
    name: str = "ChangeCoordinator"
    profile: str = "Document Change Coordinator"
    goal: str = "Manage the document adaptation process by analyzing changes and dispatching rewrite tasks."

    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        self.set_actions([AnalyzeChanges()])
        self._watch(["UserRequest", "ChangeApplicationCompleted"])
        self.document_content = None
        self.adaptation_instruction = None
        self.change_tasks = []
        self.current_task_index = 0
        self.document_path = None
        self.completed_tasks = 0

    async def _think(self) -> bool:
        self.rc.todo = None

        logger.debug(f"_think: document_content set: {bool(self.document_content)}")
        logger.debug(f"_think: adaptation_instruction set: {bool(self.adaptation_instruction)}")
        logger.debug(f"_think: change_tasks: {self.change_tasks}")
        logger.debug(f"_think: current_task_index: {self.current_task_index}")
        logger.debug(f"_think: completed_tasks: {self.completed_tasks}")
        logger.debug(f"_think: len(change_tasks): {len(self.change_tasks) if self.change_tasks else 0}")

        # 1. Process initial UserRequest if present and document_content is not yet set
        if self.rc.news and not self.document_content:
            for msg in self.rc.news:
                if msg.cause_by == "UserRequest":
                    try:
                        content = json.loads(msg.content)
                        self.document_content = content.get("document_content")
                        self.adaptation_instruction = content.get("adaptation_instruction")
                        self.document_path = content.get("document_path")
                        logger.info("Received new document adaptation request and stored content/instruction.")
                        self.rc.news.clear() # Clear news after processing
                        # After processing the initial request, re-evaluate the state to set the next todo
                        # This ensures that ANALYZE_CHANGES is set in the same _think call
                        return await self._think() 
                    except json.JSONDecodeError:
                        logger.error(f"Invalid JSON in UserRequest: {msg.content}")
                        continue
        
        # 2. Process various messages
        if self.rc.news:
            for msg in self.rc.news:
                if msg.cause_by == "ChangeApplicationCompleted":
                    self.completed_tasks += 1
                    logger.info(f"Received completion message. Completed tasks: {self.completed_tasks}/{len(self.change_tasks) if self.change_tasks else 0}")
                    self.rc.news.clear() # Clear news after processing
                    # Re-evaluate state
                    return await self._think()
                elif msg.cause_by == "TextLocationConfirmed":
                    try:
                        verification_result = json.loads(msg.content)
                        if verification_result.get("found"):
                            logger.info("✅ 文本位置验证成功，发送精确位置到ChiefPM")
                            # Forward to ChiefPM with verified location
                            self._forward_to_chief_pm_with_verified_location(verification_result)
                        else:
                            logger.error(f"❌ 文本位置验证失败: {verification_result.get('error')}")
                            # For now, we'll still send to ChiefPM but with a warning
                            self._forward_to_chief_pm_with_original_location()
                        
                        self.rc.news.clear() # Clear news after processing
                        return await self._think()
                    except json.JSONDecodeError:
                        logger.error(f"Invalid JSON in verification result: {msg.content}")
                        continue
        
        # 3. Determine the next todo based on internal state
        if self.document_content and self.adaptation_instruction and not self.change_tasks:
            self.rc.todo = "ANALYZE_CHANGES"
            logger.debug(f"ChangeCoordinator thinking: Ready to ANALYZE_CHANGES. TODO set to: {self.rc.todo}")
            return True

        elif self.change_tasks and self.current_task_index < len(self.change_tasks):
            self.rc.todo = "DISPATCH_REWRITE_TASK"
            logger.debug(f"ChangeCoordinator thinking: Found pending rewrite tasks. TODO set to: {self.rc.todo}")
            return True

        elif self.change_tasks and self.completed_tasks >= len(self.change_tasks):
            self.rc.todo = "SIGNAL_COMPLETION"
            logger.debug(f"ChangeCoordinator thinking: All tasks completed. TODO set to: {self.rc.todo}")
            return True

        logger.debug("ChangeCoordinator thinking: No new requests or pending tasks. Idling.")
        return False

    def _extract_text_from_task(self, rewrite_task: str) -> str:
        """Extract text to search for from rewrite task description"""
        # Handle common patterns
        if "Change '" in rewrite_task and "' to '" in rewrite_task:
            parts = rewrite_task.split("'")
            if len(parts) >= 4:
                return parts[1]
        elif "Replace '" in rewrite_task and "' with '" in rewrite_task:
            parts = rewrite_task.split("'")
            if len(parts) >= 4:
                return parts[1]
        
        # Fallback: return the first part that looks like text
        return rewrite_task[:100]  # Return first 100 chars as fallback
    
    def _forward_to_chief_pm_with_verified_location(self, verification_result: Dict):
        """Forward rewrite task to ChiefPM with verified location"""
        # Get the current task (since we haven't incremented yet)
        if not self.change_tasks or self.current_task_index >= len(self.change_tasks):
            logger.error("No current task to forward")
            return
            
        task = self.change_tasks[self.current_task_index]
        
        # Create task message with verified location
        task_message = {
            "task_type": "document_rewrite",
            "document_content": self.document_content,
            "rewrite_task": task.get("rewrite_task"),
            "location_info": {
                "start_line": verification_result.get("start_line"),
                "start_char": verification_result.get("start_char"),
                "end_line": verification_result.get("end_line"),
                "end_char": verification_result.get("end_char")
            },
            "document_path": self.document_path
        }
        
        message = Message(
            content=json.dumps(task_message),
            role=self.profile,
            send_to="ChiefPM",
            cause_by="ChangeRequest"
        )
        
        # Publish the message through the environment
        self.rc.env.publish_message(message)
        
        # Increment the task index for the next iteration
        self.current_task_index += 1
    
    def _forward_to_chief_pm_with_original_location(self):
        """Forward rewrite task to ChiefPM with original LLM-provided location (fallback)"""
        # Get the current task (since we haven't incremented yet)
        if not self.change_tasks or self.current_task_index >= len(self.change_tasks):
            logger.error("No current task to forward")
            return
            
        task = self.change_tasks[self.current_task_index]
        
        # Create task message with original location
        task_message = {
            "task_type": "document_rewrite",
            "document_content": self.document_content,
            "rewrite_task": task.get("rewrite_task"),
            "location_info": {
                "start_line": task.get("start_line"),
                "start_char": task.get("start_char"),
                "end_line": task.get("end_line"),
                "end_char": task.get("end_char")
            },
            "document_path": self.document_path
        }
        
        message = Message(
            content=json.dumps(task_message),
            role=self.profile,
            send_to="ChiefPM",
            cause_by="ChangeRequest"
        )
        
        # Publish the message through the environment
        self.rc.env.publish_message(message)
        
        # Increment the task index for the next iteration
        self.current_task_index += 1
    
    async def _act(self) -> Message:
        # Always call _think first to update self.rc.todo based on current state
        await self._think()
        logger.info(f"--- {self.name} is acting with todo: '{self.rc.todo}' ---")

        if self.rc.todo == "ANALYZE_CHANGES":
            analyze_action = self.actions[0] # Assuming AnalyzeChanges is the first action
            if not self.document_content or not self.adaptation_instruction:
                logger.error("Document content or adaptation instruction missing for analysis.")
                return Message(content="Error: Missing document content or instruction.", role=self.profile, send_to="User")

            self.change_tasks = await self._execute_action(
                analyze_action,
                document_content=self.document_content,
                adaptation_instruction=self.adaptation_instruction
            )
            logger.info(f"Analyzed changes. Found {len(self.change_tasks)} tasks.")
            logger.debug(f"ChangeCoordinator: self.change_tasks after AnalyzeChanges: {self.change_tasks}")
            if not self.change_tasks:
                return Message(content="No changes needed or identified.", role=self.profile, send_to="User")
            
            # Reset tracking variables
            self.current_task_index = 0
            self.completed_tasks = 0
            
            return Message(content="Changes analyzed. Ready to dispatch tasks.", role=self.profile, send_to="ChangeCoordinator")

        elif self.rc.todo == "DISPATCH_REWRITE_TASK":
            task = self.change_tasks[self.current_task_index]
            logger.info(f'Dispatching rewrite task {self.current_task_index + 1}/{len(self.change_tasks)}: {task.get("rewrite_task")}')
            
            # Extract text to search for from the rewrite task
            rewrite_task = task.get("rewrite_task", "")
            text_to_find = self._extract_text_from_task(rewrite_task)
            
            if text_to_find:
                # Add precise location verification request
                verification_request = {
                    "task_type": "location_verification",
                    "document_path": self.document_path,
                    "search_text": text_to_find,
                    "approximate_line": task.get("start_line"),
                    "approximate_char": task.get("start_char"),
                    "rewrite_task": task.get("rewrite_task"),
                    "original_location_info": {
                        "start_line": task.get("start_line"),
                        "start_char": task.get("start_char"),
                        "end_line": task.get("end_line"),
                        "end_char": task.get("end_char")
                    }
                }
                
                message = Message(
                    content=json.dumps(verification_request),
                    role=self.profile,
                    send_to="TextLocationAgent",
                    cause_by="LocationVerificationRequest"
                )
                
                # Publish the verification request
                self.rc.env.publish_message(message)
                
                return Message(content=f"Task {self.current_task_index + 1} location verification requested.", role=self.profile, send_to="ChangeCoordinator")
            else:
                # Fallback: send directly to ChiefPM if we can't extract text
                logger.warning("Could not extract text from rewrite task, sending directly to ChiefPM")
                task_message = {
                    "task_type": "document_rewrite",
                    "document_content": self.document_content,
                    "rewrite_task": task.get("rewrite_task"),
                    "location_info": {
                        "start_line": task.get("start_line"),
                        "start_char": task.get("start_char"),
                        "end_line": task.get("end_line"),
                        "end_char": task.get("end_char")
                    },
                    "document_path": self.document_path
                }
                
                message = Message(
                    content=json.dumps(task_message),
                    role=self.profile,
                    send_to="ChiefPM",
                    cause_by="ChangeRequest"
                )
                
                # Publish the message through the environment
                self.rc.env.publish_message(message)
                
                # Increment the task index for the next iteration
                self.current_task_index += 1
                
                return Message(content=f"Task {self.current_task_index} dispatched to ChiefPM (no verification).", role=self.profile, send_to="ChangeCoordinator")

        elif self.rc.todo == "SIGNAL_COMPLETION":
            logger.success("All document adaptation tasks completed.")
            return Message(content="Document adaptation process successfully completed.", role=self.profile, send_to="User")

        return Message(content="Unknown task, idling.")